<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/plugins/NodeHashIndex.js | JavaScript Earl API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Ignavia/js-earl.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/BreadthFirstTree.js~BreadthFirstTree.html">BreadthFirstTree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Edge.js~Edge.html">Edge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Graph.js~Graph.html">Graph</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Path.js~Path.html">Path</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">plugins</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/EdgeHashIndex.js~EdgeHashIndex.html">EdgeHashIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/HashIndex.js~HashIndex.html">HashIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugins/NodeHashIndex.js~NodeHashIndex.html">NodeHashIndex</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/plugins/NodeHashIndex.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import HashIndex from &quot;./HashIndex.js&quot;;

/**
 * An index that maps from a hash value to the IDs of all nodes with that hash
 * value. It adds a getter and an iterator to a graph when it is plugged in.
 */
export default class NodeHashIndex extends HashIndex {

    /**
     * @param {Function} hashFunction
     * A function that gets a node as input and returns a deterministic,
     * immutable value.
     *
     * @param {Object} mixinNames
     * Provides names for the mixin functions.
     *
     * @param {String} [mixinNames.getterName]
     * The name of the getter function. This returns the IDs of all nodes with
     * the given hash. It is also possible to provide a node object instead of
     * a hash and set the second parameter to true. Then the node is hashed
     * first and the result is used as hash.
     *
     * @param {String} [mixinNames.iteratorName]
     * The name of the iterator function. This iterates over the IDs of all
     * nodes with the given hash. It is also possible to provide a node object
     * instead of a hash and set the second parameter to true. Then the node is
     * hashed first and the result is used as hash.
     *
     * @param {String} [mixinNames.counterName]
     * The name of the counter function. This returns the number of all nodes
     * with the given hash. It is also possible to provide a node object
     * instead of a hash and set the second parameter to true. Then the node is
     * hashed first and the result is used as hash.
     *
     * @param {String} [mixinNames.testerName]
     * The name of the tester function. This tests whether nodes with the given
     * hash value exist. It is also possible to provide a node object instead of
     * a hash and set the second parameter to true. Then the node is hashed
     * first and the result is used as hash.
     */
    constructor(hashFunction, {getterName, iteratorName, counterName, testerName} = {}) {
        super(hashFunction);

        /**
         * The names of the mixin functions.
         *
         * @type {Object}
         *
         * @property {String} mixinNames.getterName
         * The name of the getter function.
         *
         * @property {String} mixinNames.iteratorName
         * The name of the iterator function.
         *
         * @property {String} mixinNames.counterName
         * The name of the counter function.
         *
         * @property {String} mixinNames.testerName
         * The name of the tester function.
         *
         * @private
         */
        this.mixinNames = {getterName, iteratorName, counterName, testerName};

        /**
         * The graph this plugin was added to.
         *
         * @type {Graph}
         */
        this.graph = undefined;
    }

    /**
     * @override
     */
    register(graph) {
        this.graph = graph;

        // Add mixins
        if (this.mixinNames.getterName) {
            graph.addMethod(this.mixinNames.getterName, this.get, this);
        }
        if (this.mixinNames.iteratorName) {
            graph.addMethod(this.mixinNames.iteratorName, this.iter, this);
        }
        if (this.mixinNames.counterName) {
            graph.addMethod(this.mixinNames.counterName, this.count, this);
        }
        if (this.mixinNames.testerName) {
            graph.addMethod(this.mixinNames.testerName, this.test, this);
        }

        // Add listeners
        graph.addListener([&quot;addNodes&quot;, &quot;afterUpdateNodes&quot;],     this.add,     this) // TODO
             .addListener([&quot;removeNodes&quot;, &quot;beforeUpdateNodes&quot;], this.remove,  this)
             .addListener(&quot;reindexNodes&quot;,                       this.reindex, this);

        // Add nodes
        this.reindex();
    }

    /**
     * Returns a new NodeHashIndex using the same hash function and mixin names.
     *
     * @return {NodeHashIndex}
     * A copy of this plugin.
     *
     * @override
     */
    clone() {
        return new NodeHashIndex(this.hash, this.mixinNames);
    }

    /**
     * Clear the complete index and add all nodes again.
     *
     * @param {Event} [e]
     * The event causing this request.
     *
     * @return {[type]}   [description]
     */
    reindex(e) {
        this.hashToIds.clear();
        this.idToHash.clear();
        this.add({data: this.graph.iterNodes()});
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.4)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
